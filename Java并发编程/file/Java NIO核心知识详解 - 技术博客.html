<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java NIO核心知识详解 - 技术博客</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #34495e;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            background: linear-gradient(135deg, var(--primary), var(--dark));
            color: white;
            padding: 2rem;
            border-radius: 10px;
            margin-bottom: 2rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 1.5rem;
        }
        .meta-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            opacity: 0.8;
            border-top: 1px solid rgba(255,255,255,0.2);
            padding-top: 1rem;
        }
        .toc {
            background-color: white;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: 0 3px 10px rgba(0,0,0,0.08);
        }
        .toc h2 {
            color: var(--primary);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--secondary);
        }
        .toc ul {
            list-style-type: none;
            columns: 2;
        }
        .toc li {
            margin-bottom: 0.7rem;
            padding-left: 1.5rem;
            position: relative;
        }
        .toc li:before {
            content: "▹";
            position: absolute;
            left: 0;
            color: var(--secondary);
        }
        section {
            background: white;
            border-radius: 8px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 3px 10px rgba(0,0,0,0.08);
        }
        h2 {
            color: var(--primary);
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--secondary);
        }
        h3 {
            color: var(--dark);
            margin: 1.5rem 0 1rem;
        }
        p {
            margin-bottom: 1rem;
        }
        .highlight {
            background-color: #f8f9fa;
            border-left: 4px solid var(--secondary);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 4px 4px 0;
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }
        .comparison-table th, .comparison-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e1e4e8;
        }
        .comparison-table th {
            background-color: var(--primary);
            color: white;
        }
        .comparison-table tr:nth-child(even) {
            background-color: #f6f8fa;
        }
        .comparison-table tr:hover {
            background-color: #ebf4ff;
        }
        .code-block {
            background-color: #2d2d2d;
            color: #f8f8f2;
            border-radius: 5px;
            padding: 1.2rem;
            margin: 1.5rem 0;
            overflow-x: auto;
            font-family: 'Consolas', monospace;
        }
        .code-block .keyword {
            color: #f92672;
        }
        .code-block .type {
            color: #66d9ef;
        }
        .code-block .string {
            color: #a6e22e;
        }
        .code-block .comment {
            color: #75715e;
        }
        .diagram-container {
            background-color: white;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1.5rem 0;
            text-align: center;
            border: 1px solid #e1e4e8;
        }
        .buffer-states {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 20px;
            margin: 2rem 0;
        }
        .buffer-state {
            flex: 1;
            min-width: 250px;
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 3px 10px rgba(0,0,0,0.08);
        }
        .buffer-visual {
            height: 100px;
            background: #f1f8ff;
            border: 1px solid #c8e1ff;
            border-radius: 4px;
            margin: 1rem 0;
            position: relative;
            overflow: hidden;
        }
        .buffer-segment {
            position: absolute;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 1rem 0;
        }
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 8px;
        }
        footer {
            text-align: center;
            padding: 2rem;
            color: #6c757d;
            font-size: 0.9rem;
            border-top: 1px solid #e1e4e8;
            margin-top: 2rem;
        }
        .key-point {
            background-color: #e8f4fd;
            border-left: 4px solid var(--secondary);
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 0 4px 4px 0;
        }
        @media (max-width: 768px) {
            .toc ul {
                columns: 1;
            }
            .buffer-states {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Java NIO核心知识详解</h1>
        <div class="subtitle">深入解析Buffer、Channel与Selector的工作原理与应用</div>
        <div class="meta-info">
            <span>作者：技术博主 | 发布日期：2025年8月12日</span>
            <span>预计阅读时间：13分钟</span>
        </div>
    </header>

    <div class="toc">
        <h2>目录</h2>
        <ul>
            <li>NIO与BIO的区别</li>
            <li>Buffer核心机制详解</li>
            <li>Channel双向通信原理</li>
            <li>Selector多路复用机制</li>
            <li>NIO零拷贝技术</li>
            <li>Buffer状态变化可视化</li>
            <li>Selector工作流程图解</li>
            <li>NIO编程最佳实践</li>
            <li>性能对比与场景选择</li>
        </ul>
    </div>

    <section id="bio-vs-nio">
        <h2>NIO与BIO的本质区别</h2>
        <p>在传统的Java I/O模型（BIO）中，I/O操作是<strong>阻塞式</strong>的。当一个线程执行I/O操作时，它会被阻塞直到操作完成。这种模型在处理多个并发连接时存在明显瓶颈：</p>
        
        <div class="highlight">
            <p>BIO模型需要为每个连接创建一个线程，当并发连接数增加时：</p>
            <ul>
                <li>线程创建和切换开销急剧增大</li>
                <li>内存消耗随连接数线性增长</li>
                <li>CPU大量时间花费在线程上下文切换上</li>
            </ul>
        </div>
        
        <p>Java 1.4引入的NIO（New I/O）提供了完全不同的I/O处理模型：</p>
        
        <div class="diagram-container">
            <div class="mermaid">
                sequenceDiagram
                    participant Client
                    participant ServerThread
                    participant Kernel
                    Note over Client, Kernel: BIO模型
                    Client->>ServerThread: 请求连接
                    ServerThread->>Kernel: 发起read()系统调用
                    Kernel-->>ServerThread: 等待数据就绪（阻塞）
                    Kernel->>Kernel: 数据准备（内核空间）
                    Kernel->>ServerThread: 数据复制到用户空间
                    ServerThread->>Client: 返回响应
                    
                    Note over Client, Kernel: NIO模型
                    Client->>Selector: 请求连接
                    Selector->>Kernel: 非阻塞检查
                    Kernel-->>Selector: 立即返回状态
                    loop 轮询
                        Selector->>Selector: 检查就绪事件
                    end
                    Selector->>Channel: 处理就绪事件
                    Channel->>Buffer: 读取数据
            </div>
        </div>
        
        <div class="key-point">
            <p><strong>重要提示：</strong> NIO的性能优势主要体现在高并发和高延迟的网络环境中。当连接数较少、并发程度低或网络传输速度快时，NIO不一定优于BIO。</p>
        </div>
    </section>

    <section id="buffer">
        <h2>Buffer核心机制详解</h2>
        <p>Buffer是NIO的数据容器，所有读写操作都通过Buffer进行。与BIO的流式操作不同，NIO是面向缓冲区的。</p>
        
        <h3>Buffer关键属性</h3>
        <p>每个Buffer都有四个核心属性控制数据读写：</p>
        
        <div class="diagram-container">
            <div class="mermaid">
                classDiagram
                    class Buffer {
                        -int capacity
                        -int limit
                        -int position
                        -int mark
                        +flip() void
                        +clear() void
                        +rewind() void
                        +mark() void
                        +reset() void
                    }
                    note for Buffer "0 <= mark <= position <= limit <= capacity"
            </div>
        </div>
        
        <table class="comparison-table">
            <tr>
                <th>属性</th>
                <th>描述</th>
                <th>写模式</th>
                <th>读模式</th>
            </tr>
            <tr>
                <td>capacity</td>
                <td>缓冲区最大容量，创建时设置不可变</td>
                <td colspan="2" style="text-align:center;">固定值</td>
            </tr>
            <tr>
                <td>limit</td>
                <td>可读写数据边界</td>
                <td>等于capacity</td>
                <td>等于实际数据量</td>
            </tr>
            <tr>
                <td>position</td>
                <td>下一个读写位置索引</td>
                <td>当前写入位置</td>
                <td>当前读取位置</td>
            </tr>
            <tr>
                <td>mark</td>
                <td>临时标记位置</td>
                <td colspan="2" style="text-align:center;">可选标记</td>
            </tr>
        </table>
        
        <h3>Buffer状态转换</h3>
        <div class="buffer-states">
            <div class="buffer-state">
                <h4>初始状态</h4>
                <div class="buffer-visual">
                    <div class="buffer-segment" style="left:0; width:100%; background:#3498db;">
                        capacity
                    </div>
                    <div class="buffer-segment" style="left:0; width:100%; background:none; border:2px dashed #e74c3c;">
                        position=0, limit=capacity
                    </div>
                </div>
                <p>新创建的Buffer处于写模式，position=0，limit=capacity</p>
            </div>
            
            <div class="buffer-state">
                <h4>写入数据后</h4>
                <div class="buffer-visual">
                    <div class="buffer-segment" style="left:0; width:40%; background:#2ecc71;">已写入数据</div>
                    <div class="buffer-segment" style="left:40%; width:60%; background:#3498db;">剩余空间</div>
                    <div class="buffer-segment" style="left:40%; width:60%; background:none; border:2px dashed #e74c3c;">
                        position=3
                    </div>
                </div>
                <p>写入3个字符后，position移动到3</p>
            </div>
            
            <div class="buffer-state">
                <h4>flip()之后</h4>
                <div class="buffer-visual">
                    <div class="buffer-segment" style="left:0; width:40%; background:#2ecc71;">可读数据</div>
                    <div class="buffer-segment" style="left:40%; width:60%; background:#3498db;">不可访问</div>
                    <div class="buffer-segment" style="left:0; width:40%; background:none; border:2px dashed #e74c3c;">
                        position=0, limit=3
                    </div>
                </div>
                <p>flip()切换为读模式，position重置为0，limit设为3</p>
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: #2ecc71;"></div>
                <span>已使用区域</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #3498db;"></div>
                <span>可用区域</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="border: 2px dashed #e74c3c; background: none;"></div>
                <span>位置标记</span>
            </div>
        </div>
        
        <h3>Buffer代码示例</h3>
        <div class="code-block">
            <span class="keyword">public class</span> <span class="type">CharBufferDemo</span> {<br>
            &nbsp;&nbsp;<span class="keyword">public static void</span> main(String[] args) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// 分配容量为8的CharBuffer</span><br>
            &nbsp;&nbsp;&nbsp;&nbsp;CharBuffer buffer = CharBuffer.allocate(<span class="number">8</span>);<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// 写入3个字符</span><br>
            &nbsp;&nbsp;&nbsp;&nbsp;buffer.put(<span class="string">'a'</span>).put(<span class="string">'b'</span>).put(<span class="string">'c'</span>);<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// 切换为读模式</span><br>
            &nbsp;&nbsp;&nbsp;&nbsp;buffer.flip();<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// 读取数据</span><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span> (buffer.hasRemaining()) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(buffer.get());<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// 清空缓冲区</span><br>
            &nbsp;&nbsp;&nbsp;&nbsp;buffer.clear();<br>
            &nbsp;&nbsp;}<br>
            }
        </div>
    </section>

    <section id="channel">
        <h2>Channel双向通信原理</h2>
        <p>Channel是NIO的核心抽象，代表与数据源（文件、网络套接字等）的连接。与BIO单向流不同，Channel是双向的。</p>
        
        <div class="diagram-container">
            <div class="mermaid">
                graph LR
                    A[文件/网络] &lt;--&gt; B[Channel]
                    B &lt;--&gt; C[Buffer]
                    C &lt;--&gt; D[应用程序]
            </div>
        </div>
        
        <h3>Channel主要类型</h3>
        <table class="comparison-table">
            <tr>
                <th>Channel类型</th>
                <th>用途</th>
                <th>特点</th>
            </tr>
            <tr>
                <td>FileChannel</td>
                <td>文件读写</td>
                <td>支持文件锁、内存映射</td>
            </tr>
            <tr>
                <td>SocketChannel</td>
                <td>TCP客户端</td>
                <td>非阻塞网络通信</td>
            </tr>
            <tr>
                <td>ServerSocketChannel</td>
                <td>TCP服务端</td>
                <td>监听传入连接</td>
            </tr>
            <tr>
                <td>DatagramChannel</td>
                <td>UDP通信</td>
                <td>支持组播</td>
            </tr>
        </table>
        
        <h3>Channel核心方法</h3>
        <div class="code-block">
            <span class="comment">// 文件读取示例</span><br>
            <span class="keyword">try</span> (RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data.txt"</span>, <span class="string">"r"</span>)) {<br>
            &nbsp;&nbsp;FileChannel channel = file.getChannel();<br>
            &nbsp;&nbsp;ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);<br>
            <br>
            &nbsp;&nbsp;<span class="keyword">int</span> bytesRead = channel.read(buffer);<br>
            &nbsp;&nbsp;<span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;buffer.flip(); <span class="comment">// 切换为读模式</span><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span> (buffer.hasRemaining()) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print((<span class="keyword">char</span>) buffer.get());<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;&nbsp;&nbsp;buffer.clear(); <span class="comment">// 清空缓冲区准备下一次读取</span><br>
            &nbsp;&nbsp;&nbsp;&nbsp;bytesRead = channel.read(buffer);<br>
            &nbsp;&nbsp;}<br>
            }
        </div>
    </section>

    <section id="selector">
        <h2>Selector多路复用机制</h2>
        <p>Selector是NIO实现高并发的核心，允许单个线程管理多个Channel。基于事件驱动的I/O多路复用模型。</p>
        
        <div class="diagram-container">
            <div class="mermaid">
                graph TD
                    A[Channel1] -->|注册| B(Selector)
                    C[Channel2] -->|注册| B
                    D[Channel3] -->|注册| B
                    B -->|轮询| E{事件检查}
                    E -->|OP_ACCEPT| F[处理新连接]
                    E -->|OP_READ| G[读取数据]
                    E -->|OP_WRITE| H[写入数据]
            </div>
        </div>
        
        <h3>Selector关键组件</h3>
        <table class="comparison-table">
            <tr>
                <th>组件</th>
                <th>作用</th>
                <th>说明</th>
            </tr>
            <tr>
                <td>SelectionKey</td>
                <td>事件类型标识</td>
                <td>包含事件类型和关联的Channel</td>
            </tr>
            <tr>
                <td>selectedKeys()</td>
                <td>就绪事件集合</td>
                <td>需要处理的事件集合</td>
            </tr>
            <tr>
                <td>keys()</td>
                <td>所有注册的Channel</td>
                <td>Selector管理的所有Channel</td>
            </tr>
        </table>
        
        <h3>Selector事件类型</h3>
        <ul>
            <li><strong>OP_ACCEPT</strong>：接受连接事件（ServerSocketChannel）</li>
            <li><strong>OP_CONNECT</strong>：连接完成事件（SocketChannel）</li>
            <li><strong>OP_READ</strong>：数据可读事件</li>
            <li><strong>OP_WRITE</strong>：数据可写事件</li>
        </ul>
        
        <h3>Selector使用示例</h3>
        <div class="code-block">
            <span class="comment">// 创建Selector</span><br>
            Selector selector = Selector.open();<br>
            ServerSocketChannel server = ServerSocketChannel.open();<br>
            server.bind(new InetSocketAddress(8080));<br>
            server.configureBlocking(false);<br>
            <br>
            <span class="comment">// 注册ACCEPT事件</span><br>
            server.register(selector, SelectionKey.OP_ACCEPT);<br>
            <br>
            <span class="keyword">while</span> (true) {<br>
            &nbsp;&nbsp;<span class="keyword">int</span> readyChannels = selector.select(); <span class="comment">// 阻塞直到有事件</span><br>
            &nbsp;&nbsp;Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>
            &nbsp;&nbsp;Iterator&lt;SelectionKey&gt; iter = keys.iterator();<br>
            <br>
            &nbsp;&nbsp;<span class="keyword">while</span> (iter.hasNext()) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;SelectionKey key = iter.next();<br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span> (key.isAcceptable()) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// 处理新连接</span><br>
            &nbsp;&nbsp;&nbsp;&nbsp;} <span class="keyword">else if</span> (key.isReadable()) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// 读取数据</span><br>
            &nbsp;&nbsp;&nbsp;&nbsp;} <span class="keyword">else if</span> (key.isWritable()) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// 写入数据</span><br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;&nbsp;&nbsp;iter.remove(); <span class="comment">// 必须移除已处理事件</span><br>
            &nbsp;&nbsp;}<br>
            }
        </div>
    </section>

    <section id="zero-copy">
        <h2>NIO零拷贝技术</h2>
        <p>零拷贝是提升I/O性能的关键技术，避免CPU在内存间复制数据，减少上下文切换。</p>
        
        <div class="diagram-container">
            <div class="mermaid">
                flowchart LR
                    subgraph 传统IO
                        A[磁盘文件] --> B[内核缓冲区]
                        B --> C[用户空间缓冲区]
                        C --> D[Socket缓冲区]
                        D --> E[网卡]
                    end
                    
                    subgraph 零拷贝
                        F[磁盘文件] --> G[内核缓冲区]
                        G --> H[网卡]
                    end
            </div>
        </div>
        
        <h3>零拷贝实现方式</h3>
        <table class="comparison-table">
            <tr>
                <th>技术</th>
                <th>CPU拷贝</th>
                <th>DMA拷贝</th>
                <th>系统调用</th>
                <th>上下文切换</th>
            </tr>
            <tr>
                <td>传统方法</td>
                <td>2次</td>
                <td>2次</td>
                <td>read+write</td>
                <td>4次</td>
            </tr>
            <tr>
                <td>mmap+write</td>
                <td>1次</td>
                <td>2次</td>
                <td>mmap+write</td>
                <td>4次</td>
            </tr>
            <tr>
                <td>sendfile</td>
                <td>1次</td>
                <td>2次</td>
                <td>sendfile</td>
                <td>2次</td>
            </tr>
            <tr>
                <td>sendfile+DMA收集</td>
                <td>0次</td>
                <td>2次</td>
                <td>sendfile</td>
                <td>2次</td>
            </tr>
        </table>
        
        <h3>Java零拷贝实现</h3>
        <div class="code-block">
            <span class="comment">// 内存映射文件</span><br>
            FileChannel channel = FileChannel.open(Path.of("data.bin"));<br>
            MappedByteBuffer buffer = channel.map(<br>
            &nbsp;&nbsp;MapMode.READ_ONLY, <span class="comment">// 只读模式</span><br>
            &nbsp;&nbsp;0, <span class="comment">// 起始位置</span><br>
            &nbsp;&nbsp;channel.size() <span class="comment">// 映射区域大小</span><br>
            );<br>
            <br>
            <span class="comment">// 文件通道传输</span><br>
            FileChannel source = FileChannel.open(Path.of("source.bin"));<br>
            FileChannel dest = FileChannel.open(Path.of("dest.bin"), StandardOpenOption.WRITE);<br>
            source.transferTo(0, source.size(), dest); <span class="comment">// 零拷贝传输</span>
        </div>
        
        <div class="key-point">
            <p><strong>最佳实践：</strong> 对于需要处理超大文件的场景，使用MappedByteBuffer或FileChannel.transferTo()可以显著提升性能。</p>
        </div>
    </section>

    <section id="conclusion">
        <h2>总结与最佳实践</h2>
        <p>Java NIO提供了强大的非阻塞I/O处理能力，特别适合高并发网络应用。核心要点总结：</p>
        
        <ul>
            <li><strong>Buffer</strong>：数据容器，掌握position/limit/capacity状态转换</li>
            <li><strong>Channel</strong>：双向数据传输通道，替代传统流</li>
            <li><strong>Selector</strong>：多路复用核心，单线程管理大量连接</li>
            <li><strong>零拷贝</strong>：性能优化关键技术，减少CPU拷贝</li>
        </ul>
        
        <h3>技术选型建议</h3>
        <table class="comparison-table">
            <tr>
                <th>场景</th>
                <th>推荐技术</th>
                <th>原因</th>
            </tr>
            <tr>
                <td>低并发短连接</td>
                <td>BIO</td>
                <td>编程简单，资源消耗少</td>
            </tr>
            <tr>
                <td>高并发长连接</td>
                <td>NIO</td>
                <td>多路复用，资源利用率高</td>
            </tr>
            <tr>
                <td>超大文件传输</td>
                <td>AIO + 零拷贝</td>
                <td>异步操作，减少CPU拷贝</td>
            </tr>
            <tr>
                <td>复杂网络应用</td>
                <td>Netty框架</td>
                <td>封装NIO，提供高级抽象</td>
            </tr>
        </table>
        
        <div class="highlight">
            <p><strong>性能数据参考：</strong> 在10K并发连接下，NIO比BIO节省约90%线程资源，AIO比NIO吞吐量提升30%~50%。</p>
        </div>
    </section>

    <footer>
        <p>© 2025 Java技术博客 | 本文内容基于JavaGuide的《Java NIO核心知识总结》编写</p>
        <p>完整代码示例：<a href="#">GitHub仓库链接</a></p>
    </footer>
</body>
</html>