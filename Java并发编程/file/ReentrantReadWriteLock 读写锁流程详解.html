<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ReentrantReadWriteLock 读写锁流程详解</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            width: 100%;
            max-width: 1400px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 25px;
            width: 100%;
            background: rgba(0, 30, 60, 0.6);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 180, 255, 0.2);
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 15px;
            background: linear-gradient(45deg, #4facfe, #00f2fe, #a6ffcb);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #e0f7ff;
            max-width: 900px;
            margin: 0 auto;
            line-height: 1.7;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
            margin: 25px 0;
            padding: 20px;
            background: rgba(0, 40, 80, 0.5);
            border-radius: 12px;
            width: 100%;
            border: 1px solid rgba(100, 180, 255, 0.2);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1rem;
            padding: 8px 15px;
            background: rgba(0, 20, 40, 0.4);
            border-radius: 8px;
        }
        
        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .content {
            display: flex;
            width: 100%;
            gap: 30px;
            margin-top: 20px;
        }
        
        .visualization {
            flex: 3;
            background: rgba(0, 30, 60, 0.5);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 1px solid rgba(100, 180, 255, 0.2);
        }
        
        .explanation {
            flex: 2;
            background: rgba(0, 30, 60, 0.5);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 180, 255, 0.2);
            overflow-y: auto;
            max-height: 800px;
        }
        
        .explanation h2 {
            font-size: 1.8rem;
            margin-bottom: 25px;
            color: #4facfe;
            text-align: center;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .step-info {
            background: rgba(0, 60, 120, 0.3);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 25px;
            border-left: 4px solid #00f2fe;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .step-info h3 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #00f2fe;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .step-details {
            line-height: 1.7;
            margin-bottom: 20px;
            padding-left: 5px;
            font-size: 1.05rem;
        }
        
        .state-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            background: rgba(0, 20, 40, 0.4);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .state-table th {
            background: rgba(74, 107, 227, 0.6);
            padding: 12px 15px;
            text-align: left;
            font-weight: 600;
        }
        
        .state-table td {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(100, 180, 255, 0.2);
        }
        
        .state-table tr:last-child td {
            border-bottom: none;
        }
        
        .lock-states {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-bottom: 35px;
            width: 100%;
        }
        
        .lock-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0, 20, 40, 0.4);
            padding: 25px;
            border-radius: 15px;
            position: relative;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            min-width: 200px;
        }
        
        .lock-label {
            position: absolute;
            top: 15px;
            left: 20px;
            font-size: 1.1rem;
            font-weight: bold;
            color: #4facfe;
        }
        
        .state-circle {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #1a2a6c, #4facfe);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            font-size: 1.2rem;
            font-weight: bold;
            position: relative;
            z-index: 2;
            border: 3px solid rgba(100, 200, 255, 0.3);
            margin-top: 15px;
        }
        
        .write-state {
            background: linear-gradient(135deg, #1a2a6c, #d76d77);
        }
        
        .state-value {
            font-size: 3rem;
            margin-top: 10px;
            color: #00f2fe;
            text-shadow: 0 0 15px rgba(0, 242, 254, 0.7);
        }
        
        .write-value {
            color: #ff6b6b;
            text-shadow: 0 0 15px rgba(255, 107, 107, 0.7);
        }
        
        .queue-container {
            width: 100%;
            min-height: 250px;
            background: rgba(0, 20, 40, 0.4);
            border-radius: 15px;
            padding: 25px;
            position: relative;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            margin-bottom: 30px;
        }
        
        .queue-title {
            text-align: center;
            margin-bottom: 25px;
            color: #00f2fe;
            font-size: 1.5rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .queue {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 40px;
            min-height: 180px;
        }
        
        .node {
            width: 180px;
            height: 220px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 15px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            position: relative;
            transition: all 0.4s ease;
            border: 2px solid rgba(100, 180, 255, 0.3);
        }
        
        .node.reader {
            background: linear-gradient(135deg, #1e3c72, #4facfe);
        }
        
        .node.writer {
            background: linear-gradient(135deg, #3a1c71, #d76d77);
        }
        
        .node.head::before {
            content: 'HEAD';
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            padding: 5px 15px;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: bold;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }
        
        .node.tail::after {
            content: 'TAIL';
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            padding: 5px 15px;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: bold;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }
        
        .node.locked {
            box-shadow: 0 0 20px #00f2fe, 0 0 35px #4facfe;
            animation: pulse 1.5s infinite;
            border-color: #00f2fe;
        }
        
        .node.writer.locked {
            box-shadow: 0 0 20px #ff6b6b, 0 0 35px #d76d77;
            border-color: #ff6b6b;
            animation: pulse-red 1.5s infinite;
        }
        
        .node.blocked {
            opacity: 0.8;
            filter: grayscale(40%);
            background: linear-gradient(135deg, #5a5a5a, #3a3a3a);
        }
        
        .node-type {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 12px;
            color: #00f2fe;
            text-align: center;
        }
        
        .writer-type {
            color: #ff6b6b;
        }
        
        .thread-info {
            font-size: 1.3rem;
            font-weight: bold;
            margin: 8px 0;
            text-align: center;
        }
        
        .status-info {
            font-size: 1.05rem;
            margin: 5px 0;
            color: #ffcc00;
            text-align: center;
            font-weight: 500;
        }
        
        .pointer-info {
            font-size: 0.95rem;
            margin: 3px 0;
            color: #a6ffcb;
            text-align: center;
            font-weight: 500;
            background: rgba(166, 255, 203, 0.15);
            padding: 4px 8px;
            border-radius: 4px;
            width: 100%;
        }
        
        .pointer-info i {
            margin-right: 5px;
            color: #4facfe;
        }
        
        .wait-status {
            background: rgba(255, 204, 0, 0.25);
            padding: 6px 12px;
            border-radius: 6px;
            margin-top: 12px;
            font-weight: bold;
            text-align: center;
        }
        
        .arrow {
            font-size: 2.5rem;
            color: #4facfe;
            display: flex;
            align-items: center;
            text-shadow: 0 0 10px rgba(79, 172, 254, 0.7);
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 25px;
            margin-top: 20px;
            width: 100%;
        }
        
        button {
            padding: 14px 35px;
            font-size: 1.2rem;
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        button:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            background: linear-gradient(135deg, #3a9dfc, #00e0f0);
        }
        
        button:disabled {
            background: linear-gradient(135deg, #7a9fc2, #7fd4d9);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .step-indicator {
            font-size: 1.3rem;
            margin-top: 20px;
            font-weight: bold;
            background: rgba(0, 60, 120, 0.4);
            padding: 12px 30px;
            border-radius: 30px;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .thread-states {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
            width: 100%;
            flex-wrap: wrap;
        }
        
        .thread-card {
            background: rgba(0, 40, 80, 0.5);
            border-radius: 12px;
            padding: 18px;
            min-width: 160px;
            text-align: center;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        
        .reader-card {
            border-color: #4facfe;
        }
        
        .writer-card {
            border-color: #d76d77;
        }
        
        .thread-card.active {
            background: rgba(74, 107, 227, 0.5);
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.6);
            transform: scale(1.05);
        }
        
        .writer-card.active {
            background: rgba(215, 109, 119, 0.5);
            box-shadow: 0 0 20px rgba(215, 109, 119, 0.6);
        }
        
        .thread-card.blocked {
            background: rgba(215, 109, 119, 0.5);
            box-shadow: 0 0 15px rgba(215, 109, 119, 0.5);
        }
        
        .thread-card h4 {
            color: #00f2fe;
            margin-bottom: 12px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .writer-card h4 {
            color: #ff6b6b;
        }
        
        .thread-state {
            font-weight: bold;
            font-size: 1.15rem;
            min-height: 30px;
        }
        
        .thread-card i {
            font-size: 1.5rem;
        }
        
        .thread-card .fa-running { color: #4facfe; }
        .writer-card .fa-running { color: #ff6b6b; }
        .thread-card .fa-pause-circle { color: #d76d77; }
        .thread-card .fa-clock { color: #a6ffcb; }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 10px #00f2fe, 0 0 20px #4facfe; }
            50% { box-shadow: 0 0 20px #00f2fe, 0 0 40px #4facfe; }
            100% { box-shadow: 0 0 10px #00f2fe, 0 0 20px #4facfe; }
        }
        
        @keyframes pulse-red {
            0% { box-shadow: 0 0 10px #ff6b6b, 0 0 20px #d76d77; }
            50% { box-shadow: 0 0 20px #ff6b6b, 0 0 40px #d76d77; }
            100% { box-shadow: 0 0 10px #ff6b6b, 0 0 20px #d76d77; }
        }
        
        @media (max-width: 1100px) {
            .content {
                flex-direction: column;
            }
            
            .lock-states {
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }
            
            .queue {
                gap: 25px;
            }
            
            .node {
                width: 160px;
                height: 200px;
                padding: 15px;
            }
            
            h1 {
                font-size: 2.3rem;
            }
        }
        
        @media (max-width: 768px) {
            .thread-states {
                gap: 15px;
            }
            
            .thread-card {
                min-width: 140px;
                padding: 15px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
            
            button {
                width: 100%;
                max-width: 300px;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-lock"></i> ReentrantReadWriteLock 读写锁流程详解</h1>
            <p class="subtitle">本可视化展示了读写锁的获取和释放流程，包括读锁(共享)和写锁(独占)的特性，以及线程在同步队列中的状态变化</p>
        </header>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #1e3c72;"></div>
                <span>读锁节点</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #3a1c71;"></div>
                <span>写锁节点</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(135deg, #4facfe, #00f2fe);"></div>
                <span>持有读锁</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(135deg, #d76d77, #ff6b6b);"></div>
                <span>持有写锁</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffcc00;"></div>
                <span>SIGNAL状态(-1)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #d76d77;"></div>
                <span>阻塞线程</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4facfe;"></div>
                <span>运行中读线程</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff6b6b;"></div>
                <span>运行中写线程</span>
            </div>
        </div>
        
        <div class="content">
            <div class="visualization">
                <div class="lock-states">
                    <div class="lock-state">
                        <div class="lock-label">读锁状态</div>
                        <div class="state-circle">
                            <div>读锁</div>
                            <div class="state-value">0</div>
                            <div>readHolds</div>
                        </div>
                    </div>
                    <div class="lock-state">
                        <div class="lock-label">写锁状态</div>
                        <div class="state-circle write-state">
                            <div>写锁</div>
                            <div class="state-value write-value">0</div>
                            <div>writeHolds</div>
                        </div>
                    </div>
                </div>
                
                <div class="queue-container">
                    <div class="queue-title">
                        <i class="fas fa-list-ol"></i> AQS同步队列 (CLH队列)
                    </div>
                    <div class="queue">
                        <!-- 队列节点将通过JS动态生成 -->
                        <div style="color: #aaa; font-size: 1.2rem;">同步队列为空</div>
                    </div>
                </div>
                
                <div class="thread-states">
                    <div class="thread-card reader-card" id="t1-card">
                        <h4><i class="fas fa-book-reader"></i> 读线程 T1</h4>
                        <div class="thread-state">未启动</div>
                    </div>
                    <div class="thread-card reader-card" id="t2-card">
                        <h4><i class="fas fa-book-reader"></i> 读线程 T2</h4>
                        <div class="thread-state">未启动</div>
                    </div>
                    <div class="thread-card writer-card" id="t3-card">
                        <h4><i class="fas fa-pen-fancy"></i> 写线程 T3</h4>
                        <div class="thread-state">未启动</div>
                    </div>
                    <div class="thread-card reader-card" id="t4-card">
                        <h4><i class="fas fa-book-reader"></i> 读线程 T4</h4>
                        <div class="thread-state">未启动</div>
                    </div>
                    <div class="thread-card writer-card" id="t5-card">
                        <h4><i class="fas fa-pen-fancy"></i> 写线程 T5</h4>
                        <div class="thread-state">未启动</div>
                    </div>
                </div>
                
                <div class="controls">
                    <button id="prev-btn" disabled>
                        <i class="fas fa-arrow-left"></i> 上一步
                    </button>
                    <button id="next-btn">
                        下一步 <i class="fas fa-arrow-right"></i>
                    </button>
                    <button id="reset-btn">
                        <i class="fas fa-sync-alt"></i> 重置
                    </button>
                </div>
                
                <div class="step-indicator">
                    <i class="fas fa-list-ol"></i> 步骤 1/12: 初始状态
                </div>
            </div>
            
            <div class="explanation">
                <h2><i class="fas fa-info-circle"></i> 流程说明</h2>
                <div class="step-info">
                    <h3><i class="fas fa-play-circle"></i> 步骤 1: 初始状态</h3>
                    <div class="step-details">
                        <p>读锁状态: <strong>0</strong> (无读锁)</p>
                        <p>写锁状态: <strong>0</strong> (无写锁)</p>
                        <p>同步队列: <strong>空</strong></p>
                        <p>所有线程尚未启动</p>
                        <p class="pointer-info"><i class="fas fa-info-circle"></i> 读写锁特性: 读锁共享，写锁独占</p>
                    </div>
                    
                    <table class="state-table">
                        <tr>
                            <th>状态</th>
                            <th>值</th>
                            <th>描述</th>
                        </tr>
                        <tr>
                            <td>读锁</td>
                            <td>0</td>
                            <td>无读锁持有</td>
                        </tr>
                        <tr>
                            <td>写锁</td>
                            <td>0</td>
                            <td>无写锁持有</td>
                        </tr>
                        <tr>
                            <td>head</td>
                            <td>null</td>
                            <td>队列头节点</td>
                        </tr>
                        <tr>
                            <td>tail</td>
                            <td>null</td>
                            <td>队列尾节点</td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 步骤数据 - 包含读写锁的完整流程
        const steps = [
            {
                title: "步骤 1: 初始状态",
                readState: 0,
                writeState: 0,
                queue: [],
                activeThreads: [],
                blockedThreads: [],
                explanation: {
                    title: "步骤 1: 初始状态",
                    details: "读锁状态: 0 (无读锁)\n写锁状态: 0 (无写锁)\n同步队列: 空\n所有线程尚未启动\n\n读写锁特性:\n- 读锁共享: 多个线程可同时获取读锁\n- 写锁独占: 同一时刻只有一个线程可获取写锁"
                }
            },
            {
                title: "步骤 2: T1获取读锁",
                readState: 1,
                writeState: 0,
                queue: [],
                activeThreads: ["T1"],
                blockedThreads: [],
                explanation: {
                    title: "步骤 2: T1获取读锁（成功）",
                    details: "T1调用readLock().lock()，成功获取读锁\n读锁状态: 1 (T1持有读锁)\n写锁状态: 0 (无写锁)\n同步队列: 仍为空\n\n读锁特性:\n- 读锁是共享的，其他读线程可以同时获取"
                }
            },
            {
                title: "步骤 3: T2获取读锁",
                readState: 2,
                writeState: 0,
                queue: [],
                activeThreads: ["T1", "T2"],
                blockedThreads: [],
                explanation: {
                    title: "步骤 3: T2获取读锁（成功）",
                    details: "T2调用readLock().lock()，成功获取读锁\n读锁状态: 2 (T1和T2持有读锁)\n写锁状态: 0 (无写锁)\n同步队列: 仍为空\n\n读锁特性:\n- 多个读线程可以同时持有读锁\n- 读锁计数器递增"
                }
            },
            {
                title: "步骤 4: T3尝试获取写锁",
                readState: 2,
                writeState: 0,
                queue: [
                    { id: "t3", type: "writer", thread: "T3", waitStatus: 0, isHead: true, isTail: true, locked: false, blocked: true,
                      prevId: null, nextId: null }
                ],
                activeThreads: ["T1", "T2"],
                blockedThreads: ["T3"],
                explanation: {
                    title: "步骤 4: T3尝试获取写锁（阻塞）",
                    details: "T3调用writeLock().lock()，尝试获取写锁\n由于有读锁被持有(T1和T2)，写锁获取失败\nT3被加入同步队列并阻塞\n\n写锁特性:\n- 写锁是独占的，需要等待所有读锁释放\n- 写锁优先级高于读锁"
                }
            },
            {
                title: "步骤 5: T4尝试获取读锁",
                readState: 2,
                writeState: 0,
                queue: [
                    { id: "t3", type: "writer", thread: "T3", waitStatus: -1, isHead: true, isTail: false, locked: false, blocked: true,
                      prevId: null, nextId: "t4" },
                    { id: "t4", type: "reader", thread: "T4", waitStatus: 0, isHead: false, isTail: true, locked: false, blocked: true,
                      prevId: "t3", nextId: null }
                ],
                activeThreads: ["T1", "T2"],
                blockedThreads: ["T3", "T4"],
                explanation: {
                    title: "步骤 5: T4尝试获取读锁（阻塞）",
                    details: "T4调用readLock().lock()，尝试获取读锁\n虽然读锁是共享的，但队列中有写锁等待(T3)\n为了避免写锁饥饿，T4被加入队列并阻塞\n\n公平性策略:\n- 当有写锁等待时，新读锁请求需要排队\n- 防止写锁无限等待"
                }
            },
            {
                title: "步骤 6: T1释放读锁",
                readState: 1,
                writeState: 0,
                queue: [
                    { id: "t3", type: "writer", thread: "T3", waitStatus: -1, isHead: true, isTail: false, locked: false, blocked: true,
                      prevId: null, nextId: "t4" },
                    { id: "t4", type: "reader", thread: "T4", waitStatus: 0, isHead: false, isTail: true, locked: false, blocked: true,
                      prevId: "t3", nextId: null }
                ],
                activeThreads: ["T2"],
                blockedThreads: ["T3", "T4"],
                explanation: {
                    title: "步骤 6: T1释放读锁",
                    details: "T1调用readLock().unlock()，释放读锁\n读锁状态从2减至1 (T2仍持有读锁)\n由于仍有读锁被持有，T3继续阻塞\n\n读锁释放:\n- 读锁计数器递减\n- 只有当计数器归零时，才会唤醒写锁"
                }
            },
            {
                title: "步骤 7: T2释放读锁",
                readState: 0,
                writeState: 0,
                queue: [
                    { id: "t3", type: "writer", thread: "T3", waitStatus: 0, isHead: true, isTail: false, locked: false, blocked: false,
                      prevId: null, nextId: "t4" },
                    { id: "t4", type: "reader", thread: "T4", waitStatus: 0, isHead: false, isTail: true, locked: false, blocked: true,
                      prevId: "t3", nextId: null }
                ],
                activeThreads: [],
                blockedThreads: ["T4"],
                explanation: {
                    title: "步骤 7: T2释放读锁（唤醒T3）",
                    details: "T2调用readLock().unlock()，释放读锁\n读锁状态归零，写锁T3被唤醒\nT3尝试获取写锁\n\n锁降级:\n- 写锁可以降级为读锁\n- 但读锁不能升级为写锁"
                }
            },
            {
                title: "步骤 8: T3获取写锁",
                readState: 0,
                writeState: 1,
                queue: [
                    { id: "t4", type: "reader", thread: "T4", waitStatus: 0, isHead: true, isTail: true, locked: false, blocked: true,
                      prevId: null, nextId: null }
                ],
                activeThreads: ["T3"],
                blockedThreads: ["T4"],
                explanation: {
                    title: "步骤 8: T3获取写锁（成功）",
                    details: "T3被唤醒后成功获取写锁\n写锁状态: 1 (T3持有写锁)\n读锁状态: 0 (无读锁)\nT4仍在队列中等待\n\n写锁特性:\n- 写锁是独占的，其他所有线程被阻塞\n- 包括读线程和写线程"
                }
            },
            {
                title: "步骤 9: T5尝试获取写锁",
                readState: 0,
                writeState: 1,
                queue: [
                    { id: "t4", type: "reader", thread: "T4", waitStatus: -1, isHead: true, isTail: false, locked: false, blocked: true,
                      prevId: null, nextId: "t5" },
                    { id: "t5", type: "writer", thread: "T5", waitStatus: 0, isHead: false, isTail: true, locked: false, blocked: true,
                      prevId: "t4", nextId: null }
                ],
                activeThreads: ["T3"],
                blockedThreads: ["T4", "T5"],
                explanation: {
                    title: "步骤 9: T5尝试获取写锁（阻塞）",
                    details: "T5调用writeLock().lock()，尝试获取写锁\n由于T3持有写锁，T5被加入队列并阻塞\nT4仍在队列中等待\n\n写锁竞争:\n- 写锁之间是互斥的\n- 按照FIFO顺序获取"
                }
            },
            {
                title: "步骤 10: T3释放写锁",
                readState: 0,
                writeState: 0,
                queue: [
                    { id: "t4", type: "reader", thread: "T4", waitStatus: 0, isHead: true, isTail: false, locked: false, blocked: false,
                      prevId: null, nextId: "t5" },
                    { id: "t5", type: "writer", thread: "T5", waitStatus: 0, isHead: false, isTail: true, locked: false, blocked: true,
                      prevId: "t4", nextId: null }
                ],
                activeThreads: [],
                blockedThreads: ["T5"],
                explanation: {
                    title: "步骤 10: T3释放写锁（唤醒T4）",
                    details: "T3调用writeLock().unlock()，释放写锁\n唤醒队列中的第一个节点T4\n由于T4是读锁，会尝试获取读锁\n\n唤醒策略:\n- 唤醒队列中的第一个等待节点\n- 如果是读锁，会继续唤醒后续连续的读锁"
                }
            },
            {
                title: "步骤 11: T4获取读锁",
                readState: 1,
                writeState: 0,
                queue: [
                    { id: "t5", type: "writer", thread: "T5", waitStatus: 0, isHead: true, isTail: true, locked: false, blocked: true,
                      prevId: null, nextId: null }
                ],
                activeThreads: ["T4"],
                blockedThreads: ["T5"],
                explanation: {
                    title: "步骤 11: T4获取读锁（成功）",
                    details: "T4被唤醒后成功获取读锁\n读锁状态: 1 (T4持有读锁)\n写锁状态: 0 (无写锁)\nT5仍在队列中等待\n\n读锁共享:\n- 如果有其他读锁在队列中且连续，会一起被唤醒\n- 但T5是写锁，所以不会继续唤醒"
                }
            },
            {
                title: "步骤 12: T4释放读锁",
                readState: 0,
                writeState: 0,
                queue: [
                    { id: "t5", type: "writer", thread: "T5", waitStatus: 0, isHead: true, isTail: true, locked: false, blocked: false,
                      prevId: null, nextId: null }
                ],
                activeThreads: [],
                blockedThreads: [],
                explanation: {
                    title: "步骤 12: T4释放读锁（唤醒T5）",
                    details: "T4调用readLock().unlock()，释放读锁\n读锁状态归零，唤醒T5\nT5尝试获取写锁\n\n最终状态:\n- T5将获取写锁\n- 队列再次为空\n- 演示了完整的读写锁生命周期"
                }
            }
        ];

        let currentStep = 0;
        const queueContainer = document.querySelector('.queue');
        const readStateValue = document.querySelectorAll('.state-value')[0];
        const writeStateValue = document.querySelectorAll('.state-value')[1];
        const stepIndicator = document.querySelector('.step-indicator');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const resetBtn = document.getElementById('reset-btn');
        const explanation = document.querySelector('.step-info');
        
        // 线程卡片
        const threadCards = {
            'T1': document.getElementById('t1-card'),
            'T2': document.getElementById('t2-card'),
            'T3': document.getElementById('t3-card'),
            'T4': document.getElementById('t4-card'),
            'T5': document.getElementById('t5-card')
        };

        // 渲染当前步骤
        function renderStep(stepIndex) {
            const step = steps[stepIndex];
            
            // 更新锁状态
            readStateValue.textContent = step.readState;
            writeStateValue.textContent = step.writeState;
            
            // 更新步骤指示器
            stepIndicator.textContent = `${step.title} (${stepIndex + 1}/${steps.length})`;
            
            // 更新解释
            explanation.innerHTML = `
                <h3><i class="fas fa-play-circle"></i> ${step.explanation.title}</h3>
                <div class="step-details">${step.explanation.details.replace(/\n/g, '<br>')}</div>
                ${generateStateTable(step)}
            `;
            
            // 渲染队列
            renderQueue(step.queue);
            
            // 更新线程状态
            updateThreadCards(step);
            
            // 更新按钮状态
            prevBtn.disabled = stepIndex === 0;
            nextBtn.disabled = stepIndex === steps.length - 1;
        }

        // 生成状态表格
        function generateStateTable(step) {
            let head = 'null';
            let tail = 'null';
            
            if (step.queue.length > 0) {
                const headNode = step.queue.find(node => node.isHead);
                const tailNode = step.queue.find(node => node.isTail);
                head = headNode ? headNode.id : 'null';
                tail = tailNode ? tailNode.id : 'null';
            }
            
            return `
                <table class="state-table">
                    <tr>
                        <th>状态</th>
                        <th>值</th>
                        <th>描述</th>
                    </tr>
                    <tr>
                        <td>读锁</td>
                        <td>${step.readState}</td>
                        <td>${step.readState === 0 ? '无读锁持有' : `${step.readState}个读锁持有`}</td>
                    </tr>
                    <tr>
                        <td>写锁</td>
                        <td>${step.writeState}</td>
                        <td>${step.writeState === 0 ? '无写锁持有' : '写锁被持有'}</td>
                    </tr>
                    <tr>
                        <td>head</td>
                        <td>${head}</td>
                        <td>队列头节点</td>
                    </tr>
                    <tr>
                        <td>tail</td>
                        <td>${tail}</td>
                        <td>队列尾节点</td>
                    </tr>
                </table>
            `;
        }

        // 渲染队列
        function renderQueue(queue) {
            queueContainer.innerHTML = '';
            
            if (queue.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.textContent = '同步队列为空';
                emptyMsg.style.color = '#aaa';
                emptyMsg.style.fontSize = '1.2rem';
                emptyMsg.style.marginTop = '20px';
                queueContainer.appendChild(emptyMsg);
                return;
            }
            
            queue.forEach((node, index) => {
                const nodeEl = document.createElement('div');
                nodeEl.className = 'node';
                
                if (node.type === 'reader') {
                    nodeEl.classList.add('reader');
                } else if (node.type === 'writer') {
                    nodeEl.classList.add('writer');
                }
                
                if (node.locked) {
                    nodeEl.classList.add('locked');
                }
                
                if (node.blocked) {
                    nodeEl.classList.add('blocked');
                }
                
                if (node.isHead) {
                    nodeEl.classList.add('head');
                }
                
                if (node.isTail) {
                    nodeEl.classList.add('tail');
                }
                
                nodeEl.innerHTML = `
                    <div class="node-type ${node.type === 'writer' ? 'writer-type' : ''}">
                        ${node.type === 'reader' ? '读锁节点' : '写锁节点'}
                    </div>
                    ${node.thread ? `<div class="thread-info">${node.thread}</div>` : ''}
                    <div class="status-info">${node.locked ? '持有锁' : node.blocked ? '阻塞中' : '等待中'}</div>
                    <div class="pointer-info"><i class="fas fa-arrow-left"></i> prev: ${node.prevId || 'null'}</div>
                    <div class="pointer-info"><i class="fas fa-arrow-right"></i> next: ${node.nextId || 'null'}</div>
                    <div class="wait-status">waitStatus: ${node.waitStatus} ${node.waitStatus === -1 ? '(SIGNAL)' : ''}</div>
                `;
                
                queueContainer.appendChild(nodeEl);
                
                // 添加箭头（除了最后一个节点）
                if (index < queue.length - 1) {
                    const arrow = document.createElement('div');
                    arrow.className = 'arrow';
                    arrow.innerHTML = '→';
                    queueContainer.appendChild(arrow);
                }
            });
        }

        // 更新线程卡片
        function updateThreadCards(step) {
            // 重置所有卡片
            Object.values(threadCards).forEach(card => {
                card.classList.remove('active', 'blocked');
                const stateEl = card.querySelector('.thread-state');
                stateEl.innerHTML = '<i class="fas fa-clock"></i> 未启动';
            });
            
            // 更新活动线程
            step.activeThreads.forEach(thread => {
                const activeCard = threadCards[thread];
                activeCard.classList.add('active');
                const stateEl = activeCard.querySelector('.thread-state');
                
                if (thread === 'T3' || thread === 'T5') {
                    stateEl.innerHTML = '<i class="fas fa-running"></i> 运行中 (持有写锁)';
                } else {
                    stateEl.innerHTML = '<i class="fas fa-running"></i> 运行中 (持有读锁)';
                }
            });
            
            // 更新阻塞线程
            step.blockedThreads.forEach(thread => {
                const blockedCard = threadCards[thread];
                blockedCard.classList.add('blocked');
                const stateEl = blockedCard.querySelector('.thread-state');
                stateEl.innerHTML = '<i class="fas fa-pause-circle"></i> 阻塞中';
            });
            
            // 更新等待线程
            ['T1', 'T2', 'T3', 'T4', 'T5'].forEach(thread => {
                if (!step.activeThreads.includes(thread) && !step.blockedThreads.includes(thread)) {
                    const threadCard = threadCards[thread];
                    const stateEl = threadCard.querySelector('.thread-state');
                    
                    if (step.readState === 0 && step.writeState === 0) {
                        stateEl.innerHTML = '<i class="fas fa-clock"></i> 未启动';
                    } else {
                        stateEl.innerHTML = '<i class="fas fa-hourglass-half"></i> 等待中';
                    }
                }
            });
        }

        // 初始化
        renderStep(currentStep);

        // 事件监听
        nextBtn.addEventListener('click', () => {
            if (currentStep < steps.length - 1) {
                currentStep++;
                renderStep(currentStep);
            }
        });

        prevBtn.addEventListener('click', () => {
            if (currentStep > 0) {
                currentStep--;
                renderStep(currentStep);
            }
        });

        resetBtn.addEventListener('click', () => {
            currentStep = 0;
            renderStep(currentStep);
        });
    </script>
</body>
</html>