<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>InnoDB & MySQL 事务流程（SVG 流程图）</title>
  <style>
    :root{
      --bg:#f0f8ff;
      --card:#e9f6ff;
      --accent:#1f77b4;
      --accent-2:#66b2ff;
      --text:#07364a;
      --muted:#4b6b82;
      font-family: Inter, "Segoe UI", Roboto, "Helvetica Neue", Arial, system-ui;
    }
    body{margin:0;background:var(--bg);color:var(--text);}
    .wrap{display:flex;gap:18px;padding:18px}
    .canvas{flex:1;background:linear-gradient(180deg,#ffffff,#f3fbff);border-radius:12px;padding:12px;box-shadow:0 8px 28px rgba(15,43,61,0.06);overflow:auto}
    .sidebar{width:360px}
    .card{background:var(--card);border-radius:10px;padding:12px;margin-bottom:12px;border:1px solid rgba(31,119,180,0.06)}
    h1{margin:6px 0;color:var(--accent)}
    .muted{color:var(--muted);font-size:13px}
    /* svg scale helper */
    svg{width:100%;height:auto;display:block}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="canvas">

<!-- Detailed SVG flowchart -->
<svg viewBox="0 0 1400 3200" xmlns="http://www.w3.org/2000/svg" aria-label="MySQL InnoDB 事务处理流程图">
  <defs>
    <linearGradient id="g1" x1="0" x2="0" y1="0" y2="1">
      <stop offset="0" stop-color="#ffffff" stop-opacity="1" />
      <stop offset="1" stop-color="#e8f9ff" stop-opacity="1" />
    </linearGradient>
    <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="5" orient="auto">
      <path d="M0,0 L10,5 L0,10 z" fill="#1f77b4"></path>
    </marker>
    <filter id="soft" x="-20%" y="-20%" width="140%" height="140%">
      <feDropShadow dx="0" dy="6" stdDeviation="10" flood-color="#0f2b3d" flood-opacity="0.06"/>
    </filter>
    <style type="text/css"><![CDATA[
      .box { fill: url(#g1); stroke:#4a9cd6; stroke-width:1.6; rx:12; filter: url(#soft); }
      .box-title { font-size:15px; font-weight:700; fill:#0b4f71 }
      .box-tiny { font-size:13px; fill:#07364a }
      .arrow-line { stroke:#1f77b4; stroke-width:2; fill:none; marker-end:url(#arrow) }
      .dashed { stroke-dasharray:6 6; opacity:0.8 }
      .note { font-size:12px; fill:#2f556b }
      .panel { fill:#ffffff; stroke:rgba(31,119,180,0.06); rx:10 }
    ]]></style>
  </defs>

  <!-- title -->
  <rect x="30" y="20" width="1340" height="64" fill="#ffffff" rx="10" stroke="rgba(31,119,180,0.06)"/>
  <text x="60" y="62" font-size="22" fill="#0b4f71" font-weight="700">MySQL（InnoDB）事务处理流程 — 详细流程图</text>
  <text x="64" y="86" class="note">按执行顺序展示：事务开始 → SQL 准备 → Undo/Redo 日志 → Buffer Pool 修改 → 提交 → 异步刷页 → 清理 & 回滚分支</text>

  <!-- Left column main flow: stages stacked vertically -->
  <!-- Stage 1 -->
  <g transform="translate(40,120)">
    <rect class="box" x="0" y="0" width="980" height="140"></rect>
    <text class="box-title" x="22" y="30">阶段 1 — 事务开始</text>
    <text class="box-tiny" x="22" y="56">• 客户端发送：BEGIN / START TRANSACTION / 设置 autocommit=0</text>
    <text class="box-tiny" x="22" y="76">• Connector：验证权限、为连接分配线程</text>
    <text class="box-tiny" x="22" y="96">• InnoDB：为事务分配唯一 trx_id（用于 MVCC、锁管理）</text>
  </g>

  <path class="arrow-line" d="M520 260 L520 320" />

  <!-- Stage 2 -->
  <g transform="translate(40,360)">
    <rect class="box" x="0" y="0" width="980" height="220"></rect>
    <text class="box-title" x="22" y="30">阶段 2 — SQL 执行准备</text>
    <text class="box-tiny" x="22" y="56">• 客户端发送 DML（UPDATE / INSERT / DELETE）</text>
    <text class="box-tiny" x="22" y="76">• Server 层处理：</text>
    <text class="box-tiny" x="44" y="96">- 解析器（Lexer / Parser）：生成解析树</text>
    <text class="box-tiny" x="44" y="116">- 优化器：基于成本模型生成执行计划</text>
    <text class="box-tiny" x="44" y="136">- 执行器：准备调用存储引擎接口</text>
    <text class="box-tiny" x="22" y="156">• InnoDB 准备：检查约束并尝试获取锁（行锁 / 意向锁）</text>
  </g>

  <path class="arrow-line" d="M520 580 L520 640" />

  <!-- Stage 3: Undo Log -->
  <g transform="translate(40,700)">
    <rect class="box" x="0" y="0" width="980" height="220"></rect>
    <text class="box-title" x="22" y="30">阶段 3 — Undo Log 生成（WAL 原则）</text>
    <text class="box-tiny" x="22" y="56">• WAL（Write-Ahead Logging）：先写 Undo，再修改内存数据</text>
    <text class="box-tiny" x="22" y="76">• Undo Log 内容：trx_id、roll_ptr、修改前数据镜像、回滚信息</text>
    <text class="box-tiny" x="22" y="96">• 作用：</text>
    <text class="box-tiny" x="44" y="116">- 回滚时恢复数据</text>
    <text class="box-tiny" x="44" y="136">- 提供 MVCC 历史版本（Read View 可见性）</text>
  </g>

  <path class="arrow-line" d="M520 920 L520 980" />

  <!-- Stage 4: Buffer Pool Modify -->
  <g transform="translate(40,1020)">
    <rect class="box" x="0" y="0" width="980" height="260"></rect>
    <text class="box-title" x="22" y="30">阶段 4 — 数据修改（Buffer Pool 操作）</text>
    <text class="box-tiny" x="22" y="56">• 若目标页不在 Buffer Pool，则从磁盘读取到内存</text>
    <text class="box-tiny" x="22" y="76">• 在 Buffer Pool 页中应用修改（更新行数据）</text>
    <text class="box-tiny" x="22" y="96">• 标记为脏页（Dirty Page），表示内存与磁盘不一致</text>
    <text class="box-tiny" x="22" y="116">• 如果有索引：更新索引页或写入 Change Buffer（非唯一索引）</text>
    <text class="box-tiny" x="22" y="136">• Doublewrite 机制保护页写入完整性（物理刷盘时）</text>
  </g>

  <path class="arrow-line" d="M520 1280 L520 1340" />

  <!-- Stage 5: Redo Log -->
  <g transform="translate(40,1400)">
    <rect class="box" x="0" y="0" width="980" height="200"></rect>
    <text class="box-title" x="22" y="30">阶段 5 — Redo Log 生成（保证持久性）</text>
    <text class="box-tiny" x="22" y="56">• 记录物理页修改：页ID、偏移、修改后的数据</text>
    <text class="box-tiny" x="22" y="76">• 写入 Redo Log Buffer（内存）</text>
    <text class="box-tiny" x="22" y="96">• Redo 用于崩溃恢复，保证已提交事务不丢失</text>
  </g>

  <!-- arrow to commit -->
  <path class="arrow-line" d="M520 1600 L520 1660" />

  <!-- Stage 6: Commit -->
  <g transform="translate(40,1720)">
    <rect class="box" x="0" y="0" width="980" height="300"></rect>
    <text class="box-title" x="22" y="30">阶段 6 — 事务提交（关键）</text>
    <text class="box-tiny" x="22" y="56">• 客户端发送 COMMIT</text>
    <text class="box-tiny" x="22" y="76">• 将 Redo Log Buffer 中的日志刷盘到 ib_logfile（必须刷盘）</text>
    <text class="box-tiny" x="22" y="96">• 若启用 binlog：采用两阶段提交以保证 Redo 与 binlog 的一致性</text>
    <text class="box-tiny" x="22" y="116">• Redo 刷盘后事务被视为已提交（即使数据页尚未刷盘）</text>
    <text class="box-tiny" x="22" y="136">• 释放所有锁，允许被阻塞事务继续</text>
    <text class="box-tiny" x="22" y="156">• Group Commit：合并多个事务的刷盘以提升吞吐</text>
  </g>

  <path class="arrow-line" d="M520 2020 L520 2060" />

  <!-- Stage 7: Async flush -->
  <g transform="translate(40,2080)">
    <rect class="box" x="0" y="0" width="980" height="200"></rect>
    <text class="box-title" x="22" y="30">阶段 7 — 异步刷脏页（后台）</text>
    <text class="box-tiny" x="22" y="56">• Page Cleaner / Background IO 将脏页写回 .ibd 文件</text>
    <text class="box-tiny" x="22" y="76">• 异步写入不会阻塞事务提交，提升整体性能</text>
    <text class="box-tiny" x="22" y="96">• 写回后数据页与 Redo 日志的一致性逐步建立</text>
  </g>

  <path class="arrow-line" d="M520 2260 L520 2300" />

  <!-- Stage 8: Purge & return -->
  <g transform="translate(40,2320)">
    <rect class="box" x="0" y="0" width="980" height="220"></rect>
    <text class="box-title" x="22" y="30">阶段 8 — 清理阶段</text>
    <text class="box-tiny" x="22" y="56">• Purge 线程清理不再需要的 Undo Log，回收空间</text>
    <text class="box-tiny" x="22" y="76">• 释放事务相关资源</text>
    <text class="box-tiny" x="22" y="96">• 向客户端返回执行结果</text>
  </g>

  <!-- Rollback branch (from Undo/Buffer area) -->
  <path class="arrow-line dashed" d="M760 840 L1060 840 L1060 1160" />
  <g transform="translate(1060,1160)">
    <rect class="panel'" x="0" y="0" width="300" height="170" rx="10" fill="#fff" stroke="rgba(31,119,180,0.06)" />
    <text class="box-title" x="12" y="28">回滚流程（ROLLBACK）</text>
    <text class="box-tiny" x="12" y="52">• 触发：执行 ROLLBACK 或发生执行错误</text>
    <text class="box-tiny" x="12" y="72">• 使用 Undo Log：逆序应用 Undo 记录恢复旧值</text>
    <text class="box-tiny" x="12" y="92">• 释放锁并清理资源</text>
    <text class="box-tiny" x="12" y="112">• 向客户端返回回滚结果</text>
  </g>

  <!-- Right side panels: ACID, MVCC, Performance -->
  <g transform="translate(1060,40)">
    <rect class="panel" x="0" y="0" width="320" height="220"></rect>
    <text class="box-title" x="12" y="28">ACID 特性实现</text>
    <text class="box-tiny" x="12" y="54">• 原子性：Undo Log 支撑，完全回滚</text>
    <text class="box-tiny" x="12" y="74">• 一致性：约束检查 + Undo/Redo 保证数据一致</text>
    <text class="box-tiny" x="12" y="94">• 隔离性：锁与 MVCC（Read View）实现</text>
    <text class="box-tiny" x="12" y="114">• 持久性：Redo 刷盘保证（ib_logfile）</text>
  </g>

  <g transform="translate(1060,280)">
    <rect class="panel" x="0" y="0" width="320" height="220"></rect>
    <text class="box-title" x="12" y="28">MVCC 与事务关系</text>
    <text class="box-tiny" x="12" y="54">• 非锁定读通过 Undo 提供历史版本</text>
    <text class="box-tiny" x="12" y="74">• 每个事务创建 Read View 决定可见版本</text>
    <text class="box-tiny" x="12" y="94">• 版本链通过 roll_ptr / DB_ROLL_PTR 串联</text>
    <text class="box-tiny" x="12" y="114">• 读不阻塞写，写不阻塞读（典型 MVCC 优势）</text>
  </g>

  <g transform="translate(1060,520)">
    <rect class="panel" x="0" y="0" width="320" height="220"></rect>
    <text class="box-title" x="12" y="28">性能优化要点</text>
    <text class="box-tiny" x="12" y="54">• WAL：顺序写日志，提升 I/O 性能</text>
    <text class="box-tiny" x="12" y="74">• 组提交（Group Commit）：合并刷盘，减少 I/O</text>
    <text class="box-tiny" x="12" y="94">• 异步刷脏页：不影响提交延迟</text>
    <text class="box-tiny" x="12" y="114">• Change Buffer：缓存非唯一索引变更，减少随机 I/O</text>
    <text class="box-tiny" x="12" y="134">• 自适应哈希索引：自动加速热点查询</text>
  </g>

  <!-- footer note -->
  <text x="60" y="3100" class="note">注：图示为通用工作流程，不同 MySQL/InnoDB 版本在细节（线程名、参数）上可能略有差异。</text>

</svg>

    </div>
    <div class="sidebar">
      <div class="card">
        <h1>说明</h1>
        <p class="muted">已将你提供的全文要点转为结构化的 SVG 流程图，包含：各阶段详细步骤、回滚分支、以及右侧的 ACID / MVCC / 性能要点面板。</p>
      </div>
      <div class="card">
        <h3 style="color:var(--accent)">后续可做</h3>
        <p class="muted">可选项：增加图标、分栏压缩高度、加入箭头流动动画、导出高分辨率 PNG/SVG。</p>
      </div>
      <div class="card">
        <h3 style="color:var(--accent)">导出</h3>
        <p class="muted">如果需要我可以把当前画布导出为 SVG 或 PNG 文件并提供下载（需你确认导出格式）。</p>
      </div>
    </div>
  </div>
</body>
</html>
